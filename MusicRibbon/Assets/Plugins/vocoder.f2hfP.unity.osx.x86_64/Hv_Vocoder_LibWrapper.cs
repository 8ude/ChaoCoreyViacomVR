/**
 * Copyright (c) 2014,2015,2016 Enzien Audio Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, and/or
 * sublicense copies of the Software, strictly on a non-commercial basis,
 * and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * DO NOT MODIFY. THIS CODE IS MACHINE GENERATED BY THE ENZIENAUDIO HEAVY COMPILER.
 */

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Assertions;

[RequireComponent (typeof (AudioSource))]

public class Hv_Vocoder_LibWrapper : MonoBehaviour {

  // Delegate method for thread-safe receiver for float messages from the patch context
  // Example usage:
  /*
    void Start () {
        Hv_Vocoder_LibWrapper script = GetComponent<Hv_Vocoder_LibWrapper>();
        script.RegisterSendHook();
        script.FloatReceivedCallback += OnFloatMessage;
    }

    void OnFloatMessage(Hv_Vocoder_LibWrapper.FloatMessage message) {
        Debug.Log(message.receiverName + ": " + message.value);
    }
  */
  public class FloatMessage {
    public string receiverName;
    public float value;

    public FloatMessage(string name, float x) {
      receiverName = name;
      value = x;
    }
  }
  public delegate void FloatMessageReceived(FloatMessage message);
  public FloatMessageReceived FloatReceivedCallback;

  
  public float vocoder_q = 25.0f;
  public float ramp_note = 30.0f;
  public float out_gain = 100.0f;

  // internal state
  private Hv_Vocoder_Context _context;
  private float _vocoder_q = 25.0f;
  private float _ramp_note = 30.0f;
  private float _out_gain = 100.0f;

  private readonly object _bangQueueSync = new object();
  private readonly Queue<string> _bangQueue = new Queue<string>();

  public void RegisterSendHook() {
    _context.RegisterSendHook();
  }

  public void SendBangToReceiver(string receiverName) {
    lock(_bangQueueSync) {
      _bangQueue.Enqueue(receiverName);
    }
  }

  private void Awake() {
    _context = new Hv_Vocoder_Context((double) AudioSettings.outputSampleRate);
  }

  private void Start() {
    _context.SendFloatToReceiver("vocoder_q", Mathf.Clamp(vocoder_q, 0.0f, 100.0f));
    _context.SendFloatToReceiver("ramp_note", Mathf.Clamp(ramp_note, 0.0f, 127.0f));
    _context.SendFloatToReceiver("out_gain", Mathf.Clamp(out_gain, 0.0f, 1000.0f));
  }

  private void Update() {
    // retreive sent messages
    if (_context.IsSendHookRegistered()) {
      Hv_Vocoder_LibWrapper.FloatMessage tempMessage;
      while ((tempMessage = _context.msgQueue.GetNextMessage()) != null) {
        FloatReceivedCallback(tempMessage);
      }
    }
  }

  
  private void OnValidate() {
    if (_context != null) {
      if (_vocoder_q != vocoder_q) {
        _vocoder_q = vocoder_q = Mathf.Clamp(vocoder_q, 0.0f, 100.0f);
        _context.SendFloatToReceiver("vocoder_q", _vocoder_q);
      }
      if (_ramp_note != ramp_note) {
        _ramp_note = ramp_note = Mathf.Clamp(ramp_note, 0.0f, 127.0f);
        _context.SendFloatToReceiver("ramp_note", _ramp_note);
      }
      if (_out_gain != out_gain) {
        _out_gain = out_gain = Mathf.Clamp(out_gain, 0.0f, 1000.0f);
        _context.SendFloatToReceiver("out_gain", _out_gain);
      }
    }
  }
 
  private void OnAudioFilterRead(float[] buffer, int numChannels) {
    Assert.AreEqual(numChannels, _context.GetNumOutputChannels()); // invalid channel configuration
    // process parameter changes
    OnValidate();

    // process all bang events
    lock (_bangQueueSync) {
      while (_bangQueue.Count != 0) {
        _context.SendBangToReceiver(_bangQueue.Dequeue());
      }
    }

    // process dsp
    _context.Process(buffer, buffer.Length / numChannels);
  }
}

class Hv_Vocoder_Context {

  // Thread-safe message queue
  public class SendMessageQueue {
    private readonly object _msgQueueSync = new object();
    private readonly Queue<Hv_Vocoder_LibWrapper.FloatMessage> _msgQueue = new Queue<Hv_Vocoder_LibWrapper.FloatMessage>();

    public Hv_Vocoder_LibWrapper.FloatMessage GetNextMessage() {
      lock (_msgQueueSync) {
        return (_msgQueue.Count != 0) ? _msgQueue.Dequeue() : null;
      }
    }

    public void AddMessage(string receiverName, float value) {
      Hv_Vocoder_LibWrapper.FloatMessage msg = new Hv_Vocoder_LibWrapper.FloatMessage(receiverName, value);
      lock (_msgQueueSync) {
        _msgQueue.Enqueue(msg);
      }
    }
  }

  public readonly SendMessageQueue msgQueue = new SendMessageQueue();
  private readonly IntPtr _context; // handle into unmanaged memory
  private SendHook _sendHook = null;

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern IntPtr hv_vocoder_new_with_options(double sampleRate,
      int poolKb);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern void hv_vocoder_free(IntPtr ctx);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern double hv_getSampleRate(IntPtr ctx);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern int hv_getNumInputChannels(IntPtr ctx);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern int hv_getNumOutputChannels(IntPtr ctx);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern void hv_setSendHook(IntPtr ctx, SendHook sendHook);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern void hv_setPrintHook(IntPtr ctx, PrintHook printHook);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern void hv_sendBangToReceiver(IntPtr ctx, string receiverName);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern void hv_sendFloatToReceiver(IntPtr ctx,
      string receiverName, float x);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern bool hv_msg_hasFormat(IntPtr message, string format);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern float hv_msg_getFloat(IntPtr message, int index);

  [DllImport ("Hv_Vocoder_LibWrapper")]
  private static extern int hv_vocoder_process_interleaved(IntPtr ctx,
      [In] float[] inBuffer, [Out] float[] outBuffer, int numSamples);

  private delegate void PrintHook(double timeStamp, string printName,
      string message, IntPtr userData);

  private delegate void SendHook(double timeStamp, string receiverName,
      IntPtr message, IntPtr userData);

  public Hv_Vocoder_Context(double sampleRate, int poolKb=10) {
    _context = hv_vocoder_new_with_options(sampleRate, poolKb);
    hv_setPrintHook(_context, new PrintHook(OnPrint));
  }

  ~Hv_Vocoder_Context() {
    hv_vocoder_free(_context);
    GC.KeepAlive(_context);
    GC.KeepAlive(_sendHook);
  }

  public void RegisterSendHook() {
    // Note: send hook functionality only applies to messages containing a single float value
    if (_sendHook == null) {
      _sendHook = new SendHook(OnMessageSent);
      hv_setSendHook(_context, _sendHook);
    }
  }

  public bool IsSendHookRegistered() {
    return (_sendHook != null);
  }

  public double GetSampleRate() {
    return hv_getSampleRate(_context);
  }

  public int GetNumInputChannels() {
    return hv_getNumInputChannels(_context);
  }

  public int GetNumOutputChannels() {
    return hv_getNumOutputChannels(_context);
  }

  public void SendBangToReceiver(string receiverName) {
    hv_sendBangToReceiver(_context, receiverName);
  }

  public void SendFloatToReceiver(string receiverName, float x) {
    hv_sendFloatToReceiver(_context, receiverName, x);
  }

  public int Process(float[] buffer, int numFrames) {
    return hv_vocoder_process_interleaved(_context, buffer, buffer, numFrames);
  }

  private void OnPrint(double timeStamp, string printName, string message,
      IntPtr userData) {
    Debug.Log(string.Format("{0} [{1:0.000}]: {2}", printName, timeStamp, message));
  }

  private void OnMessageSent(double timeStamp, string receiverName, IntPtr message,
      IntPtr userData) {
    if (hv_msg_hasFormat(message, "f")) {
      msgQueue.AddMessage(receiverName, hv_msg_getFloat(message, 0));
    }
  }
 }